<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kolam Pattern Recognition & Generation System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-blue: #1e40af;
            --secondary-blue: #3b82f6;
            --accent-orange: #f97316;
            --success-green: #10b981;
            --warning-yellow: #f59e0b;
            --danger-red: #ef4444;
            --dark-gray: #1f2937;
            --light-gray: #f3f4f6;
            --white: #ffffff;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            line-height: 1.6;
            color: var(--dark-gray);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            min-height: 100vh;
        }

        /* Header */
        .header {
            background: rgba(255, 255, 255, 0.95);
            /* backdrop-filter: blur(20px); */
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            border-bottom: 3px solid var(--accent-orange);
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo-section {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .sih-badge {
            background: linear-gradient(135deg, var(--primary-blue), var(--secondary-blue));
            color: white;
            padding: 8px 16px;
            border-radius: 25px;
            font-weight: 700;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .project-title {
            font-size: 1.4em;
            font-weight: 700;
            color: var(--dark-gray);
        }

        .nav-menu {
            display: flex;
            gap: 30px;
            align-items: center;
        }

        .nav-item {
            color: var(--dark-gray);
            text-decoration: none;
            font-weight: 500;
            padding: 8px 16px;
            border-radius: 8px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .nav-item:hover,
        .nav-item.active {
            background: var(--secondary-blue);
            color: white;
            transform: translateY(-2px);
        }

        .team-badge {
            background: var(--accent-orange);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.85em;
        }

        /* Main Content */
        .main-container {
            margin-top: 80px;
            min-height: calc(100vh - 80px);
        }

        .page-section {
            display: none;
            padding: 40px 20px;
        }

        .page-section.active {
            display: block;
        }

        /* Problem Statement Page */
        .problem-hero {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 50px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            margin-bottom: 40px;
        }

        .problem-header {
            text-align: center;
            margin-bottom: 40px;
        }

        .problem-id {
            background: var(--danger-red);
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            font-weight: 700;
            display: inline-block;
            margin-bottom: 20px;
            font-size: 1.1em;
        }

        .problem-title {
            font-size: 2.8em;
            font-weight: 800;
            color: var(--dark-gray);
            margin-bottom: 15px;
            line-height: 1.2;
        }

        .problem-subtitle {
            font-size: 1.3em;
            color: #666;
            font-weight: 500;
        }

        .challenge-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 30px;
            margin-top: 40px;
        }

        .challenge-card {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            border-left: 5px solid var(--secondary-blue);
            transition: transform 0.3s ease;
        }

        .challenge-card:hover {
            transform: translateY(-10px);
        }

        .challenge-card h3 {
            color: var(--primary-blue);
            margin-bottom: 15px;
            font-size: 1.3em;
            font-weight: 700;
        }

        .challenge-card p {
            line-height: 1.6;
            color: #555;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 40px auto;
            max-width: 1000px;
        }

        .stat-card {
            background: linear-gradient(135deg, var(--success-green), #059669);
            color: white;
            padding: 25px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 10px 25px rgba(16, 185, 129, 0.3);
        }

        .stat-number {
            font-size: 2.5em;
            font-weight: 800;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.9em;
            opacity: 0.9;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Solution Architecture */
        .solution-container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .architecture-diagram {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 40px;
            margin-bottom: 40px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        .tech-stack {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }

        .tech-card {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            text-align: center;
            transition: transform 0.3s ease;
        }

        .tech-card:hover {
            transform: translateY(-5px);
        }

        .tech-icon {
            font-size: 3em;
            margin-bottom: 15px;
        }

        .tech-card h4 {
            color: var(--primary-blue);
            margin-bottom: 10px;
            font-weight: 700;
        }

        /* Demo Section */
        .demo-container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        .demo-header {
            text-align: center;
            margin-bottom: 40px;
        }

        .demo-header h2 {
            font-size: 2.5em;
            color: var(--dark-gray);
            font-weight: 800;
            margin-bottom: 15px;
        }

        .demo-interface {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 40px;
            align-items: start;
        }

        .control-panel {
            background: #f8fafc;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            position: sticky;
            top: 120px;
        }

        .control-section {
            margin-bottom: 30px;
        }

        .control-section h4 {
            color: var(--primary-blue);
            font-weight: 700;
            margin-bottom: 15px;
            font-size: 0.95em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-label {
            display: block;
            color: var(--dark-gray);
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 0.9em;
        }

        .control-input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        .control-input:focus {
            outline: none;
            border-color: var(--secondary-blue);
        }

        .range-input {
            height: 6px;
            background: #e5e7eb;
            border: none;
            border-radius: 3px;
        }

        .range-input::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--secondary-blue);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(59, 130, 246, 0.3);
        }

        .range-display {
            text-align: center;
            font-weight: 600;
            color: var(--secondary-blue);
            margin-top: 5px;
            font-size: 0.9em;
        }

        .algo-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 20px;
        }

        .algo-btn {
            padding: 12px 8px;
            background: linear-gradient(135deg, var(--primary-blue), var(--secondary-blue));
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.8em;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            transition: all 0.3s ease;
        }

        .algo-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(30, 64, 175, 0.4);
        }

        .action-panel {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-top: 25px;
        }

        .action-btn {
            padding: 15px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: all 0.3s ease;
            font-size: 0.85em;
        }

        .btn-clear {
            background: linear-gradient(135deg, #6b7280, #4b5563);
            color: white;
        }

        .btn-analyze {
            background: linear-gradient(135deg, var(--success-green), #059669);
            color: white;
        }

        .btn-export {
            background: linear-gradient(135deg, var(--accent-orange), #ea580c);
            color: white;
        }

        .action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
        }

        .canvas-workspace {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #pattern-canvas {
            border: 3px solid #e5e7eb;
            border-radius: 12px;
            cursor: crosshair;
            transition: all 0.3s ease;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
        }

        #pattern-canvas:hover {
            border-color: var(--secondary-blue);
            box-shadow: 0 8px 30px rgba(59, 130, 246, 0.2);
        }

        .analysis-panel {
            background: linear-gradient(135deg, var(--primary-blue), var(--secondary-blue));
            color: white;
            border-radius: 12px;
            padding: 25px;
            margin-top: 20px;
        }

        .analysis-panel h4 {
            margin-bottom: 15px;
            font-size: 1.1em;
            font-weight: 700;
        }

        .analysis-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .analysis-stat {
            text-align: center;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
        }

        .analysis-stat .number {
            font-size: 1.5em;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .analysis-stat .label {
            font-size: 0.8em;
            opacity: 0.9;
        }

        /* Team Section */
        .team-container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 50px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        .team-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 30px;
            margin-top: 40px;
        }

        .team-card {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            text-align: center;
            transition: transform 0.3s ease;
        }

        .team-card:hover {
            transform: translateY(-10px);
        }

        .member-avatar {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--secondary-blue), var(--primary-blue));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2em;
            color: white;
            margin: 0 auto 20px;
            font-weight: 700;
        }

        .member-name {
            font-size: 1.3em;
            font-weight: 700;
            color: var(--dark-gray);
            margin-bottom: 8px;
        }

        .member-role {
            color: var(--secondary-blue);
            font-weight: 600;
            margin-bottom: 15px;
            font-size: 0.95em;
        }

        .member-skills {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
        }

        .skill-tag {
            background: #f3f4f6;
            color: var(--dark-gray);
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 0.8em;
            font-weight: 500;
        }

        /* Implementation Timeline */
        .timeline-container {
            max-width: 1000px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 50px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        .timeline {
            position: relative;
            margin-top: 40px;
        }

        .timeline::before {
            content: '';
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            width: 4px;
            height: 100%;
            background: linear-gradient(to bottom, var(--primary-blue), var(--secondary-blue));
            border-radius: 2px;
        }

        .timeline-item {
            position: relative;
            margin-bottom: 50px;
            width: calc(50% - 30px);
        }

        .timeline-item:nth-child(odd) {
            left: 0;
            text-align: right;
        }

        .timeline-item:nth-child(even) {
            left: calc(50% + 30px);
            text-align: left;
        }

        .timeline-content {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            position: relative;
        }

        .timeline-date {
            background: var(--accent-orange);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 700;
            font-size: 0.85em;
            display: inline-block;
            margin-bottom: 15px;
        }

        .timeline-title {
            color: var(--primary-blue);
            font-weight: 700;
            font-size: 1.2em;
            margin-bottom: 10px;
        }

        .timeline-desc {
            color: #555;
            line-height: 1.6;
        }

        /* Mobile Responsiveness */
        @media (max-width: 1024px) {
            .demo-interface {
                grid-template-columns: 1fr;
            }
            
            .control-panel {
                order: 2;
                position: static;
            }
        }

        @media (max-width: 768px) {
            .header-content {
                flex-direction: column;
                gap: 15px;
                text-align: center;
            }

            .nav-menu {
                flex-wrap: wrap;
                justify-content: center;
            }

            .problem-title {
                font-size: 2em;
            }

            .challenge-grid,
            .tech-stack,
            .team-grid {
                grid-template-columns: 1fr;
            }

            .timeline::before {
                left: 20px;
            }

            .timeline-item {
                width: calc(100% - 60px);
                left: 40px !important;
                text-align: left !important;
            }

            .algo-buttons {
                grid-template-columns: 1fr;
            }
        }

        /* Loading and Animation States */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid var(--secondary-blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="header-content">
            <div class="logo-section">
                <div class="sih-badge">Tri</div>
                <div class="project-title">Kolam Pattern Recognition & Generation</div>
            </div>
            <nav class="nav-menu">
                <a href="#" class="nav-item active" onclick="showSection('problem')">Problem Statement</a>
                <a href="#" class="nav-item" onclick="showSection('solution')">Solution</a>
                <a href="#" class="nav-item" onclick="showSection('demo')">Live Demo</a>
                <!-- <a href="#" class="nav-item" onclick="showSection('timeline')">Implementation</a> -->
                <a href="#" class="nav-item" onclick="showSection('team')">Team</a>
                <div class="team-badge">Team Name</div>
            </nav>
        </div>
    </header>

    <!-- Main Container -->
    <main class="main-container">
        <!-- Problem Statement Section -->
        <section class="page-section active" id="problem">
            <div class="problem-hero">
                <div class="problem-header">
                    <div class="problem-id"></div>
                    <h1 class="problem-title">Digital Preservation of Traditional Indian Art Patterns</h1>
                    <p class="problem-subtitle">AI-Powered Analysis and Generation of Kolam Mathematical Designs</p>
                </div>

                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-number">5000+</div>
                        <div class="stat-label">Traditional Patterns</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">28</div>
                        <div class="stat-label">Indian States</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">95%</div>
                        <div class="stat-label">Accuracy Target</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">72hrs</div>
                        <div class="stat-label">Development Time</div>
                    </div>
                </div>
            </div>

            <div class="challenge-grid">
                <div class="challenge-card">
                    <h3>üéØ Primary Challenge</h3>
                    <p>Traditional Indian art forms like Kolam, Rangoli, and Muggu are disappearing due to urbanization and lack of digital documentation. These patterns contain sophisticated mathematical principles that need preservation and analysis.</p>
                </div>
                
                <div class="challenge-card">
                    <h3>üßÆ Mathematical Analysis</h3>
                    <p>Develop algorithms to identify and analyze mathematical properties embedded in traditional patterns: symmetry groups, tessellation, fractal characteristics, and topological features.</p>
                </div>
                
                <div class="challenge-card">
                    <h3>üíª Digital Generation</h3>
                    <p>Create an intelligent system that can generate authentic traditional patterns using computer algorithms while respecting cultural authenticity and mathematical precision.</p>
                </div>
                
                <div class="challenge-card">
                    <h3>üåê Cultural Impact</h3>
                    <p>Bridge the gap between traditional art and modern technology, making these patterns accessible to younger generations and researchers worldwide through interactive digital platforms.</p>
                </div>
            </div>
        </section>

        <!-- Solution Architecture Section -->
        <section class="page-section" id="solution">
            <div class="solution-container">
                <div class="architecture-diagram">
                    <h2 style="text-align: center; margin-bottom: 40px; font-size: 2.5em; color: var(--dark-gray); font-weight: 800;">Solution Architecture</h2>
                    
                    <div class="tech-stack">
                        <div class="tech-card">
                            <div class="tech-icon">üß†</div>
                            <h4>Pattern Recognition AI</h4>
                            <p>Machine learning algorithms for analyzing traditional pattern structures and mathematical properties</p>
                        </div>
                        <div class="tech-card">
                            <div class="tech-icon">üìê</div>
                            <h4>Mathematical Engine</h4>
                            <p>Geometry processing algorithms for symmetry detection, tessellation analysis, and fractal identification</p>
                        </div>
                        <div class="tech-card">
                            <div class="tech-icon">üé®</div>
                            <h4>Interactive Canvas</h4>
                            <p>Real-time pattern generation with grid-based drawing system and symmetry operations</p>
                        </div>
                        <div class="tech-card">
                            <div class="tech-icon">üìä</div>
                            <h4>Analytics Dashboard</h4>
                            <p>Comprehensive analysis tools for pattern complexity, mathematical properties, and cultural variations</p>
                        </div>
                        <div class="tech-card">
                            <div class="tech-icon">üíæ</div>
                            <h4>Pattern Database</h4>
                            <p>Searchable repository of traditional patterns with metadata, regional variations, and mathematical classifications</p>
                        </div>
                        <div class="tech-card">
                            <div class="tech-icon">üåê</div>
                            <h4>Web Platform</h4>
                            <p>Responsive web application for education, research, and cultural preservation with export capabilities</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Live Demo Section -->
        <section class="page-section" id="demo">
            <div class="demo-container">
                <div class="demo-header">
                    <h2>Live Pattern Generation System</h2>
                    <p>Experience the mathematical beauty of traditional Indian art through interactive creation</p>
                </div>

                <div class="demo-interface">
                    <div class="control-panel">
                        <div class="control-section">
                            <h4>Grid Configuration</h4>
                            <div class="control-group">
                                <label class="control-label">Grid Size</label>
                                <input type="range" class="control-input range-input" id="gridSize" min="5" max="20" value="12">
                                <div class="range-display" id="gridSizeDisplay">12 x 12</div>
                            </div>
                            <div class="control-group">
                                <label class="control-label">Dot Size</label>
                                <input type="range" class="control-input range-input" id="dotSize" min="2" max="8" value="4">
                                <div class="range-display" id="dotSizeDisplay">4px</div>
                            </div>
                        </div>

                        <div class="control-section">
                            <h4>Drawing Parameters</h4>
                            <div class="control-group">
                                <label class="control-label">Line Width</label>
                                <input type="range" class="control-input range-input" id="lineWidth" min="1" max="6" value="2">
                                <div class="range-display" id="lineWidthDisplay">2px</div>
                            </div>
                            <div class="control-group">
                                <label class="control-label">Drawing Mode</label>
                                <select class="control-input" id="drawingMode">
                                    <option value="lines">Straight Lines</option>
                                    <option value="curves">Curved Lines</option>
                                    <option value="loops">Loop Patterns</option>
                                    <option value="petals">Petal Designs</option>
                                </select>
                            </div>
                            <div class="control-group">
                                <label class="control-label">Symmetry Mode</label>
                                <select class="control-input" id="symmetryMode">
                                    <option value="none">Free Draw</option>
                                    <option value="horizontal">Horizontal Mirror</option>
                                    <option value="vertical">Vertical Mirror</option>
                                    <option value="both">Four-way Mirror</option>
                                    <option value="radial">Radial (8-way)</option>
                                </select>
                            </div>
                        </div>

                        <div class="control-section">
                            <h4>Algorithm Library</h4>
                            <div class="algo-buttons">
                                <button class="algo-btn" onclick="generatePattern('basic')">Basic Kolam</button>
                                <button class="algo-btn" onclick="generatePattern('flower')">Flower Pattern</button>
                                <button class="algo-btn" onclick="generatePattern('geometric')">Geometric</button>
                                <button class="algo-btn" onclick="generatePattern('spiral')">Spiral Design</button>
                                <button class="algo-btn" onclick="generatePattern('star')">Star Pattern</button>
                                <button class="algo-btn" onclick="generatePattern('mandala')">Mandala</button>
                            </div>
                        </div>

                        <div class="action-panel">
                            <button class="action-btn btn-clear" onclick="clearCanvas()">Clear Canvas</button>
                            <button class="action-btn btn-analyze" onclick="analyzePattern()">Analyze Pattern</button>
                            <button class="action-btn btn-export" onclick="exportPattern()">Export PNG</button>
                        </div>

                        <div class="analysis-panel">
                            <h4>Pattern Analysis</h4>
                            <p>Mathematical properties of the current design:</p>
                            <div class="analysis-stats">
                                <div class="analysis-stat">
                                    <div class="number" id="symmetryCount">0</div>
                                    <div class="label">Symmetries</div>
                                </div>
                                <div class="analysis-stat">
                                    <div class="number" id="pathCount">0</div>
                                    <div class="label">Paths</div>
                                </div>
                                <div class="analysis-stat">
                                    <div class="number" id="complexityScore">0</div>
                                    <div class="label">Complexity</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="canvas-workspace">
                        <canvas id="pattern-canvas" width="700" height="700"></canvas>
                    </div>
                </div>
            </div>
        </section>

        <!-- Implementation Timeline Section -->
        <section class="page-section" id="timeline">
            <div class="timeline-container">
                <h2 style="text-align: center; margin-bottom: 20px; font-size: 2.5em; color: var(--dark-gray); font-weight: 800;">Implementation Roadmap</h2>
                <p style="text-align: center; margin-bottom: 40px; font-size: 1.2em; color: #666;">72-hour development sprint breakdown</p>

                <div class="timeline">
                    <div class="timeline-item">
                        <div class="timeline-content">
                            <div class="timeline-date">Day 1: 0-8 Hours</div>
                            <div class="timeline-title">Research & Planning</div>
                            <div class="timeline-desc">Problem analysis, mathematical research, algorithm design, and system architecture planning. Study traditional Kolam patterns and identify key mathematical properties.</div>
                        </div>
                    </div>

                    <div class="timeline-item">
                        <div class="timeline-content">
                            <div class="timeline-date">Day 1: 8-16 Hours</div>
                            <div class="timeline-title">Core Engine Development</div>
                            <div class="timeline-desc">Implement grid system, basic drawing algorithms, and mathematical analysis functions. Create pattern recognition and symmetry detection algorithms.</div>
                        </div>
                    </div>

                    <div class="timeline-item">
                        <div class="timeline-content">
                            <div class="timeline-date">Day 1: 16-24 Hours</div>
                            <div class="timeline-title">UI/UX Design & Frontend</div>
                            <div class="timeline-desc">Design and implement responsive user interface, interactive canvas, and control panels. Focus on user experience and accessibility.</div>
                        </div>
                    </div>

                    <div class="timeline-item">
                        <div class="timeline-content">
                            <div class="timeline-date">Day 2: 24-40 Hours</div>
                            <div class="timeline-title">Advanced Features</div>
                            <div class="timeline-desc">Implement advanced pattern generation algorithms, symmetry operations, and mathematical analysis tools. Add export functionality and pattern library.</div>
                        </div>
                    </div>

                    <div class="timeline-item">
                        <div class="timeline-content">
                            <div class="timeline-date">Day 2: 40-56 Hours</div>
                            <div class="timeline-title">Testing & Optimization</div>
                            <div class="timeline-desc">Comprehensive testing, performance optimization, bug fixes, and cross-browser compatibility. Validate mathematical accuracy of algorithms.</div>
                        </div>
                    </div>

                    <div class="timeline-item">
                        <div class="timeline-content">
                            <div class="timeline-date">Day 3: 56-72 Hours</div>
                            <div class="timeline-title">Documentation & Presentation</div>
                            <div class="timeline-desc">Create comprehensive documentation, prepare presentation materials, and finalize deployment. Polish UI and prepare demo scenarios.</div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Team Section -->
        <section class="page-section" id="team">
            <div class="team-container">
                <h2 style="text-align: center; margin-bottom: 20px; font-size: 2.5em; color: var(--dark-gray); font-weight: 800;">Team Name</h2>
                <p style="text-align: center; margin-bottom: 40px; font-size: 1.2em; color: #666;">Interdisciplinary team combining technology, mathematics, and cultural studies</p>

                <div class="team-grid">
                    <div class="team-card">
                        <div class="member-avatar">Avatar</div>
                        <div class="member-name">Name</div>
                        <div class="member-role">Team Lead & Full-Stack Developer</div>
                        <div class="member-skills">
                            <span class="skill-tag">React</span>
                            <span class="skill-tag">Node.js</span>
                            <span class="skill-tag">Algorithm Design</span>
                            <span class="skill-tag">System Architecture</span>
                        </div>
                    </div>
                    <div class="team-card">
                        <div class="member-avatar">Avatar</div>
                        <div class="member-name">Name</div>
                        <div class="member-role">Team Lead & Full-Stack Developer</div>
                        <div class="member-skills">
                            <span class="skill-tag">React</span>
                            <span class="skill-tag">Node.js</span>
                            <span class="skill-tag">Algorithm Design</span>
                            <span class="skill-tag">System Architecture</span>
                        </div>
                    </div>                    
                </div>
            </div>
        </section>
    </main>

    <script>
        // Global variables
        const canvas = document.getElementById('pattern-canvas');
        const ctx = canvas ? canvas.getContext('2d') : null;
        
        let gridSize = 12;
        let dotSize = 4;
        let lineWidth = 2;
        let drawingMode = 'lines';
        let symmetryMode = 'none';
        let isDrawing = false;
        let lastPoint = null;
        let paths = [];
        let analysisData = {
            symmetries: 0,
            pathCount: 0,
            complexity: 0
        };

        // Navigation function
        function showSection(sectionId) {
            // Hide all sections
            document.querySelectorAll('.page-section').forEach(section => {
                section.classList.remove('active');
            });
            
            // Remove active class from nav items
            document.querySelectorAll('.nav-item').forEach(item => {
                item.classList.remove('active');
            });
            
            // Show selected section
            document.getElementById(sectionId).classList.add('active');
            
            // Add active class to clicked nav item
            event.target.classList.add('active');
            
            // Initialize canvas if demo section is shown
            if (sectionId === 'demo' && ctx) {
                setTimeout(() => {
                    initCanvas();
                    updateAnalysis();
                }, 100);
            }
        }

        // Canvas initialization
        function initCanvas() {
            if (!ctx) return;
            
            // Set canvas background
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            drawGrid();
        }

        // Draw dot grid
        function drawGrid() {
            if (!ctx) return;
            
            const spacing = Math.min(canvas.width, canvas.height) / (gridSize + 1);
            const offsetX = (canvas.width - (gridSize - 1) * spacing) / 2;
            const offsetY = (canvas.height - (gridSize - 1) * spacing) / 2;

            ctx.fillStyle = '#ef4444';
            
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const x = offsetX + i * spacing;
                    const y = offsetY + j * spacing;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, dotSize, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }
        }

        // Get nearest grid point
        function getNearestGridPoint(x, y) {
            const spacing = Math.min(canvas.width, canvas.height) / (gridSize + 1);
            const offsetX = (canvas.width - (gridSize - 1) * spacing) / 2;
            const offsetY = (canvas.height - (gridSize - 1) * spacing) / 2;

            let nearestX = Math.round((x - offsetX) / spacing) * spacing + offsetX;
            let nearestY = Math.round((y - offsetY) / spacing) * spacing + offsetY;

            return { x: nearestX, y: nearestY };
        }

        // Drawing functions
        function drawLine(fromPoint, toPoint, color = '#1e40af') {
            if (!fromPoint || !toPoint || !ctx) return;

            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            if (drawingMode === 'curves') {
                drawCurvedLine(fromPoint, toPoint);
            } else if (drawingMode === 'loops') {
                drawLoop(fromPoint, toPoint);
            } else if (drawingMode === 'petals') {
                drawPetal(fromPoint, toPoint);
            } else {
                ctx.beginPath();
                ctx.moveTo(fromPoint.x, fromPoint.y);
                ctx.lineTo(toPoint.x, toPoint.y);
                ctx.stroke();
            }
        }

        function drawCurvedLine(fromPoint, toPoint) {
            const midX = (fromPoint.x + toPoint.x) / 2;
            const midY = (fromPoint.y + toPoint.y) / 2;
            const offsetX = (toPoint.y - fromPoint.y) * 0.3;
            const offsetY = (fromPoint.x - toPoint.x) * 0.3;

            ctx.beginPath();
            ctx.moveTo(fromPoint.x, fromPoint.y);
            ctx.quadraticCurveTo(midX + offsetX, midY + offsetY, toPoint.x, toPoint.y);
            ctx.stroke();
        }

        function drawLoop(fromPoint, toPoint) {
            const centerX = (fromPoint.x + toPoint.x) / 2;
            const centerY = (fromPoint.y + toPoint.y) / 2;
            const radius = Math.min(Math.abs(toPoint.x - fromPoint.x), Math.abs(toPoint.y - fromPoint.y)) / 3;

            if (radius > 5) {
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                ctx.stroke();
            }
        }

        function drawPetal(fromPoint, toPoint) {
            const centerX = (fromPoint.x + toPoint.x) / 2;
            const centerY = (fromPoint.y + toPoint.y) / 2;
            const distance = Math.sqrt(Math.pow(toPoint.x - fromPoint.x, 2) + Math.pow(toPoint.y - fromPoint.y, 2));
            
            if (distance > 10) {
                ctx.beginPath();
                ctx.moveTo(fromPoint.x, fromPoint.y);
                ctx.bezierCurveTo(
                    fromPoint.x + (centerX - fromPoint.x) * 0.5,
                    fromPoint.y - 15,
                    toPoint.x - (toPoint.x - centerX) * 0.5,
                    toPoint.y - 15,
                    toPoint.x, toPoint.y
                );
                ctx.bezierCurveTo(
                    toPoint.x - (toPoint.x - centerX) * 0.5,
                    toPoint.y + 15,
                    fromPoint.x + (centerX - fromPoint.x) * 0.5,
                    fromPoint.y + 15,
                    fromPoint.x, fromPoint.y
                );
                ctx.stroke();
            }
        }

        // Symmetry operations
        function applySymmetry(fromPoint, toPoint) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            // Original line
            drawLine(fromPoint, toPoint);
            paths.push({ from: fromPoint, to: toPoint });

            if (symmetryMode === 'horizontal' || symmetryMode === 'both') {
                const mirrorFrom = { x: fromPoint.x, y: 2 * centerY - fromPoint.y };
                const mirrorTo = { x: toPoint.x, y: 2 * centerY - toPoint.y };
                drawLine(mirrorFrom, mirrorTo);
                paths.push({ from: mirrorFrom, to: mirrorTo });
            }

            if (symmetryMode === 'vertical' || symmetryMode === 'both') {
                const mirrorFrom = { x: 2 * centerX - fromPoint.x, y: fromPoint.y };
                const mirrorTo = { x: 2 * centerX - toPoint.x, y: toPoint.y };
                drawLine(mirrorFrom, mirrorTo);
                paths.push({ from: mirrorFrom, to: mirrorTo });
            }

            if (symmetryMode === 'both') {
                const mirrorFrom = { x: 2 * centerX - fromPoint.x, y: 2 * centerY - fromPoint.y };
                const mirrorTo = { x: 2 * centerX - toPoint.x, y: 2 * centerY - toPoint.y };
                drawLine(mirrorFrom, mirrorTo);
                paths.push({ from: mirrorFrom, to: mirrorTo });
            }

            if (symmetryMode === 'radial') {
                for (let i = 1; i < 8; i++) {
                    const angle = (i * Math.PI) / 4;
                    const cos = Math.cos(angle);
                    const sin = Math.sin(angle);
                    
                    const rotatePoint = (p) => ({
                        x: centerX + (p.x - centerX) * cos - (p.y - centerY) * sin,
                        y: centerY + (p.x - centerX) * sin + (p.y - centerY) * cos
                    });
                    
                    drawLine(rotatePoint(fromPoint), rotatePoint(toPoint));
                    paths.push({ from: rotatePoint(fromPoint), to: rotatePoint(toPoint) });
                }
            }
        }

        // Pattern generation algorithms
        function generatePattern(type) {
            clearCanvas();
            
            switch(type) {
                case 'basic':
                    generateBasicKolam();
                    break;
                case 'flower':
                    generateFlowerPattern();
                    break;
                case 'geometric':
                    generateGeometricPattern();
                    break;
                case 'spiral':
                    generateSpiralPattern();
                    break;
                case 'star':
                    generateStarPattern();
                    break;
                case 'mandala':
                    generateMandalaPattern();
                    break;
            }
            
            setTimeout(updateAnalysis, 100);
        }

        function generateBasicKolam() {
            const spacing = Math.min(canvas.width, canvas.height) / (gridSize + 1);
            const offsetX = (canvas.width - (gridSize - 1) * spacing) / 2;
            const offsetY = (canvas.height - (gridSize - 1) * spacing) / 2;

            // Square pattern with nested squares
            for (let layer = 2; layer < gridSize - 2; layer += 2) {
                const points = [
                    { x: offsetX + layer * spacing, y: offsetY + layer * spacing },
                    { x: offsetX + (gridSize - 1 - layer) * spacing, y: offsetY + layer * spacing },
                    { x: offsetX + (gridSize - 1 - layer) * spacing, y: offsetY + (gridSize - 1 - layer) * spacing },
                    { x: offsetX + layer * spacing, y: offsetY + (gridSize - 1 - layer) * spacing }
                ];

                for (let i = 0; i < points.length; i++) {
                    const nextIndex = (i + 1) % points.length;
                    drawLine(points[i], points[nextIndex]);
                    paths.push({ from: points[i], to: points[nextIndex] });
                }
            }
        }

        function generateFlowerPattern() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(canvas.width, canvas.height) * 0.25;

            // Central flower with 8 petals
            for (let i = 0; i < 8; i++) {
                const angle = (i * Math.PI) / 4;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                
                drawLine({ x: centerX, y: centerY }, { x: x, y: y });
                paths.push({ from: { x: centerX, y: centerY }, to: { x: x, y: y } });
                
                // Add petal decorations
                const petalRadius = radius * 0.4;
                for (let j = 0; j < 4; j++) {
                    const petalAngle = angle + (j * Math.PI) / 6 - Math.PI / 12;
                    const px = x + petalRadius * Math.cos(petalAngle);
                    const py = y + petalRadius * Math.sin(petalAngle);
                    drawLine({ x: x, y: y }, { x: px, y: py });
                    paths.push({ from: { x: x, y: y }, to: { x: px, y: py } });
                }
            }
        }

        function generateGeometricPattern() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const maxRadius = Math.min(canvas.width, canvas.height) * 0.35;

            // Concentric geometric shapes
            for (let i = 1; i <= 4; i++) {
                const radius = (maxRadius * i) / 4;
                const sides = 4 + i * 2; // 6, 8, 10, 12 sided polygons
                
                const points = [];
                for (let j = 0; j < sides; j++) {
                    const angle = (j * 2 * Math.PI) / sides;
                    points.push({
                        x: centerX + radius * Math.cos(angle),
                        y: centerY + radius * Math.sin(angle)
                    });
                }
                
                for (let j = 0; j < points.length; j++) {
                    const nextIndex = (j + 1) % points.length;
                    drawLine(points[j], points[nextIndex]);
                    paths.push({ from: points[j], to: points[nextIndex] });
                }
            }
        }

        function generateSpiralPattern() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            let angle = 0;
            let radius = 10;
            let lastPoint = { x: centerX, y: centerY };

            for (let i = 0; i < 120; i++) {
                angle += 0.3;
                radius += 2.5;
                
                if (radius > Math.min(canvas.width, canvas.height) * 0.35) break;
                
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                const currentPoint = { x: x, y: y };
                
                if (i > 0) {
                    drawLine(lastPoint, currentPoint);
                    paths.push({ from: { ...lastPoint }, to: { ...currentPoint } });
                }
                
                lastPoint = currentPoint;
            }
        }

        function generateStarPattern() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const outerRadius = Math.min(canvas.width, canvas.height) * 0.3;
            const innerRadius = outerRadius * 0.5;
            const points = 8;

            const starPoints = [];
            for (let i = 0; i < points * 2; i++) {
                const angle = (i * Math.PI) / points;
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                starPoints.push({
                    x: centerX + radius * Math.cos(angle),
                    y: centerY + radius * Math.sin(angle)
                });
            }
            
            // Draw star outline
            for (let i = 0; i < starPoints.length; i++) {
                const nextIndex = (i + 1) % starPoints.length;
                drawLine(starPoints[i], starPoints[nextIndex]);
                paths.push({ from: starPoints[i], to: starPoints[nextIndex] });
            }
            
            // Add internal connections
            for (let i = 0; i < points; i++) {
                const outerIndex = i * 2;
                const oppositeIndex = ((i + points / 2) * 2) % starPoints.length;
                drawLine(starPoints[outerIndex], starPoints[oppositeIndex]);
                paths.push({ from: starPoints[outerIndex], to: starPoints[oppositeIndex] });
            }
        }

        function generateMandalaPattern() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const maxRadius = Math.min(canvas.width, canvas.height) * 0.35;
            
            // Concentric circles with radial lines
            const circles = [0.3, 0.5, 0.7, 0.9];
            const rays = 16;
            
            // Draw circles
            circles.forEach(ratio => {
                const radius = maxRadius * ratio;
                ctx.strokeStyle = '#1e40af';
                ctx.lineWidth = lineWidth;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                ctx.stroke();
            });
            
            // Draw radial lines
            for (let i = 0; i < rays; i++) {
                const angle = (i * 2 * Math.PI) / rays;
                const x1 = centerX + (maxRadius * 0.3) * Math.cos(angle);
                const y1 = centerY + (maxRadius * 0.3) * Math.sin(angle);
                const x2 = centerX + (maxRadius * 0.9) * Math.cos(angle);
                const y2 = centerY + (maxRadius * 0.9) * Math.sin(angle);
                
                drawLine({ x: x1, y: y1 }, { x: x2, y: y2 });
                paths.push({ from: { x: x1, y: y1 }, to: { x: x2, y: y2 } });
            }
        }

        // Utility functions
        function clearCanvas() {
            if (!ctx) return;
            
            paths = [];
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            initCanvas();
            updateAnalysis();
        }

        function analyzePattern() {
            if (!paths.length) return;
            
            // Calculate symmetries
            let symmetries = 0;
            if (symmetryMode === 'horizontal' || symmetryMode === 'vertical') symmetries = 2;
            if (symmetryMode === 'both') symmetries = 4;
            if (symmetryMode === 'radial') symmetries = 8;
            if (symmetryMode === 'none') symmetries = 1;
            
            // Calculate complexity based on path count and intersections
            const complexity = Math.min(100, Math.floor((paths.length * 2) + (symmetries * 5)));
            
            analysisData = {
                symmetries: symmetries,
                pathCount: paths.length,
                complexity: complexity
            };
            
            updateAnalysis();
        }

        function updateAnalysis() {
            document.getElementById('symmetryCount').textContent = analysisData.symmetries;
            document.getElementById('pathCount').textContent = analysisData.pathCount;
            document.getElementById('complexityScore').textContent = analysisData.complexity;
        }

        function exportPattern() {
            if (!canvas) return;
            
            const link = document.createElement('a');
            link.download = `kolam-pattern-${Date.now()}.png`;
            link.href = canvas.toDataURL('image/png', 1.0);
            link.click();
        }

        // Canvas event handlers
        if (canvas) {
            canvas.addEventListener('mousedown', (e) => {
                isDrawing = true;
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                lastPoint = getNearestGridPoint(x, y);
            });

            canvas.addEventListener('mousemove', (e) => {
                if (!isDrawing) return;
                
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const currentPoint = getNearestGridPoint(x, y);
                
                if (lastPoint && (currentPoint.x !== lastPoint.x || currentPoint.y !== lastPoint.y)) {
                    if (symmetryMode === 'none') {
                        drawLine(lastPoint, currentPoint);
                        paths.push({ from: {...lastPoint}, to: {...currentPoint} });
                    } else {
                        applySymmetry(lastPoint, currentPoint);
                    }
                    lastPoint = currentPoint;
                    updateAnalysis();
                }
            });

            canvas.addEventListener('mouseup', () => {
                isDrawing = false;
                lastPoint = null;
                analyzePattern();
            });
        }

        // Control event listeners
        document.getElementById('gridSize')?.addEventListener('input', (e) => {
            gridSize = parseInt(e.target.value);
            document.getElementById('gridSizeDisplay').textContent = `${gridSize} x ${gridSize}`;
            if (ctx) clearCanvas();
        });

        document.getElementById('dotSize')?.addEventListener('input', (e) => {
            dotSize = parseInt(e.target.value);
            document.getElementById('dotSizeDisplay').textContent = `${dotSize}px`;
            if (ctx) clearCanvas();
        });

        document.getElementById('lineWidth')?.addEventListener('input', (e) => {
            lineWidth = parseInt(e.target.value);
            document.getElementById('lineWidthDisplay').textContent = `${lineWidth}px`;
        });

        document.getElementById('drawingMode')?.addEventListener('change', (e) => {
            drawingMode = e.target.value;
        });

        document.getElementById('symmetryMode')?.addEventListener('change', (e) => {
            symmetryMode = e.target.value;
            analyzePattern();
        });

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            if (ctx) {
                initCanvas();
                updateAnalysis();
            }
        });
    </script>
</body>
</html>